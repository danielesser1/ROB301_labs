#!/usr/bin/env python

import rospy
import math
import time
from sensor_msgs.msg import LaserScan
from geometry_msgs.msg import Twist
from std_msgs.msg import String
import numpy as np
import sys, select, os
if os.name == 'nt':
    import msvcrt
else:
    import tty, termios

def getKey():
    if os.name == 'nt':
      return msvcrt.getch()

    tty.setraw(sys.stdin.fileno())
    rlist, _, _ = select.select([sys.stdin], [], [], 0.1)
    if rlist:
        key = sys.stdin.read(1)
    else:
        key = ''

    termios.tcsetattr(sys.stdin, termios.TCSADRAIN, settings)
    return key

class PID(object):
	def __init__(self, p_gain, i_gain, d_gain, i_min, i_max):
		"""Constructor, zeros out Pid values when created and
		initialize Pid-gains and integral term limits.

		Parameters:
		  p_gain     The proportional gain.
          i_gain     The integral gain.
          d_gain     The derivative gain.
          i_min      The integral lower limit. 
          i_max      The integral upper limit.
        """
		self._p_gain = p_gain
		self._i_gain = i_gain
		self._d_gain = d_gain
		self._i_min = i_min
		self._i_max= i_max
		self.reset()

	def reset(self):
		self._p_error_last = 0.0 # Save position state for derivative
                                 # state calculation.
		self._p_error = 0.0 # Position error.
		self._d_error = 0.0 # Derivative error.
		self._i_error = 0.0 # Integator error.
		self._cmd = 0.0 # Command to send.
		self._last_time = None # Used for automatic calculation of dt.
        

	def update_PID(self, p_error, dt=None):
		if dt is None:
			cur_time = time.time()
			if self._last_time is None: 
				self._last_time = cur_time
			dt = cur_time - self._last_time
			self._last_time = cur_time

		self._p_error = p_error
		if dt == 0 or math.isnan(dt) or math.isinf(dt):
			print("dt:{}".format(dt))
			return 0.0

		p_term = self._p_gain * self._p_error
		print("p_gain:{}, p_error:{}, p_term:{}".format(self._p_gain, self._p_error, p_term))

		self._i_error += dt* self._p_error
		i_term = self._i_gain * self._i_error

		# Limit i_term so that the limit is meaningful in the output
		if i_term > self._i_max and self._i_gain != 0:
			i_term = self._i_max
			self._i_error = i_term / self._i_gain
		elif i_term < self._i_min and self._i_gain != 0:
			i_term = self._i_min
			self._i_error = i_term / self._i_gain

		print("i_error:{}, i_gain:{}, p_error:{}, dt:{}, i_term:{}".format(self._i_error, self._i_gain, self._p_error, dt, i_term))

		# Calculate the derivative error
		self._d_error = (self._p_error - self._p_error_last) / dt
		self._p_error_last = self._p_error
        
		# Calculate derivative contribution to command 
		d_term = self._d_gain * self._d_error
        
		print("p_error:{}, p_error_last:{}, dt:{}, d_error:{}, d_gain:{}, d_term:{}".format(self._p_error, self._p_error_last, dt, self._d_error, self._d_gain, d_term))
		self._cmd = p_term + i_term + d_term
		
		print("cmd:{}".format(self._cmd))
		return self._cmd


class PIDcontrol():
    def __init__(self):
	self.p_gain = 0.1
	self.i_gain = 0.0
	self.d_gain = 0.001
	self.interval_max = 0.02
	self.interval_min = -0.02

    self._cmd_pub = rospy.Publisher('cmd_vel', Twist, queue_size=1)
    self.controller = PID(0.18, 0.0002, 0.002, -0.02, 0.02)
    self.color_sub = rospy.Subscriber('color_mono', String, self.camera_callback, queue_size=1)

    self.state_sub = rospy.Subscriber('state', String, self.state_callback)
    self.goal = 1.22
    self.stop = False
    self.error = 0
    rospy.spin()


    def camera_callback(self, data):
        index = int(data.data)
        mid = 320
        print('index:{}'.format(index))
        error = -(index - mid)/200
        self.error = error

    def state_callback(self, data):
        state = float(data)
        if state >= self.goal:
            self.stop=True


    def follow_the_line(self):
        error = self.error
        cmd = self.controller.update_PID(error)
        print('cmd:{} error:{}'.format(cmd, error))
        twist = Twist()
        twist.linear.x = 0.05
        twist.angular.z = cmd
        if cmd < 0:
            print('turning right')
        else:
            print('turning left')
        self._cmd_pub.publish(twist)



def main():
    rospy.init_node('Lab3')
    PID = PIDcontrol()
    try:
        while(1):
            key = getKey()
            PID.follow_the_line()
            if (key == '\x03') or PID.stop:
                break
    except rospy.ROSInterruptException:
        print("comm failed")

    finally:
        twist = Twist()
        twist.linear.x = 0.0; twist.linear.y = 0.0; twist.linear.z = 0.0
        twist.angular.x = 0.0; twist.angular.y = 0.0; twist.angular.z = 0.0
        PID._cmd_pub.publish(twist)

if __name__ == '__main__':
    main()


